<?xml version='1.0' encoding='utf-8'?>
<struct id="lm951_parser" name="lm951_parser" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <brief> Parser state and callbacks</brief>
  <doc>This structure encapsulates the parser's state machine's... uh, state.
It also contains function pointers to callbacks which the user provides.
This allows you to respond to events in the state machin as they happen.
</doc>
  <field id="lm951_parser::cs" name="cs">
    <brief>The current state ID of the Ragel state machine</brief>
    <type builtin="yes" name="int" />
  </field>
  <field id="lm951_parser::on_ok_response" name="on_ok_response">
    <brief>Action to take when OK response is parsed</brief>
    <type class="function" qualifier="*">
      <result>
        <type builtin="yes" name="void" />
      </result>
      <arguments />
    </type>
  </field>
  <field id="lm951_parser::on_error_response" name="on_error_response">
    <brief>Action to take when ERROR response is parsed</brief>
    <type class="function" qualifier="*">
      <result>
        <type builtin="yes" name="void" />
      </result>
      <arguments />
    </type>
  </field>
  <field id="lm951_parser::on_error" name="on_error">
    <brief>Action to take when a lexing error occures</brief>
    <type class="function" qualifier="*">
      <result>
        <type builtin="yes" name="void" />
      </result>
      <arguments>
        <type builtin="yes" name="int" />
        <type builtin="yes" name="char" />
      </arguments>
    </type>
  </field>
  <field id="lm951_parser::on_completed" name="on_completed">
    <brief>Action to take when a command or response is parsed</brief>
    <doc>The default action is to break out of the parsing loop, meaning
lm951_input(s) will return without processing anymore data.</doc>
    <type class="function" qualifier="*">
      <result>
        <type builtin="yes" name="void" />
      </result>
      <arguments />
    </type>
  </field>
  <function id="lm951_init" name="lm951_init">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="lm951_init::state" name="state">
      <type name="lm951_parser" qualifier="*" ref="lm951_parser#lm951_parser" />
    </argument>
  </function>
  <function id="lm951_inputs" name="lm951_inputs">
    <brief> Parse the data</brief>
    <doc>When data is received, feed it into this function. The <ref ref="lm951_parser#lm951_inputs::state">state</ref> argument
will be updated accordingly to a new state based on the contents of
<ref ref="lm951_parser#lm951_inputs::data">data</ref>.

</doc>
    <return>
      <doc>TODO</doc>
      <type name="LM951_ISTATUS" ref="index#LM951_ISTATUS" />
    </return>
    <argument id="lm951_inputs::state" name="state">
      <doc>The current state and callbacks</doc>
      <type name="lm951_parser" qualifier="*" ref="lm951_parser#lm951_parser" />
    </argument>
    <argument id="lm951_inputs::data" name="data">
      <doc>The text/bytes to parse</doc>
      <type builtin="yes" name="char" qualifier=" const *" />
    </argument>
    <argument id="lm951_inputs::length" name="length">
      <doc>The length of the <ref ref="lm951_parser#lm951_inputs::data">data</ref></doc>
      <type name="size_t" qualifier="*" />
    </argument>
  </function>
  <function id="lm951_restart" name="lm951_restart">
    <brief> Set the parser to the begining state</brief>
    <doc>This sets the cs member of <ref ref="lm951_parser#lm951_restart::state">state</ref> to the start value. If <ref ref="lm951_parser#lm951_restart::state">state</ref>
is NULL then the default global state variable is used.
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="lm951_restart::state" name="state">
      <doc>A parser's state or NULL</doc>
      <type name="lm951_parser" qualifier="*" ref="lm951_parser#lm951_parser" />
    </argument>
  </function>
</struct>
